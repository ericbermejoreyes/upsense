import { Column, Entity, BeforeInsert, OneToMany, ManyToMany, OneToOne, JoinColumn} from 'typeorm';import { ObjectType, Field } from 'type-graphql';import { Audit } from './Audit';import { Zone } from './Zone';import { BaseEntity } from './BaseEntity';import hash from '../../../components/helpers/Hash';import { RefreshToken } from './RefreshToken';import {UserRoleTypes} from "../../../components/types/UserRoleTypes";const crypto = require('crypto');/** * The User Entity, this entity holds data for User, Manager and User */@ObjectType()@Entity({ name: 'users' })export class User extends BaseEntity{    @Column({ type: 'enum', enum: ['admin', 'manager', 'user'], nullable: false, default: 'user'})    role!: UserRoleTypes;    @Field(() => String)    @Column({ type: 'text', unique: true, nullable: true })    username!: string;    @Column({ type: 'text', unique: false, nullable: false })    password!: string;    @Column({ type: 'text', nullable: false})    salt!: string;    @Field(() => String, { nullable: true })    @Column({ type: 'text', nullable: true, default: '' })    image?: string;    @Field(() => String)    @Column({ type: 'text', nullable: false, default: '', name: 'first_name' })    firstName!: string;    @Field(() => String)    @Column({ type: 'text', nullable: false, default: '', name: 'last_name' })    lastName!: string;    @Field(() => String)    @Column({ type: 'text', unique: true, nullable: false, default: '' })    email!: string;    @Field(() => String, { nullable: true })    @Column({ type: 'text', nullable: true, name: 'mobile', unique: true })    mobile?: string;    @OneToOne(() => RefreshToken, refreshToken => refreshToken.user, { onDelete: 'SET NULL' })    @JoinColumn({name: 'refresh_token_id'})    refreshToken!: RefreshToken;    @OneToMany(() => Audit, audit => audit.user)    audits!: Audit[];    @ManyToMany(() => Zone, zone => zone.users, { cascade: ['insert', 'update'] })    zones!: Zone[];    /**     * Before inserting the data, generate the salt and hash the password     */    @BeforeInsert()    hashPassword()    {        this.salt = crypto.randomBytes(16).toString('hex');        this.password = hash.password(this.password, this.salt);    }    /**     * Validate if the password provided matched     * @param password     */    validatePassword(password: string)    {        return this.password === hash.password(password, this.salt);    }}