import {Column, Entity, BeforeInsert, OneToMany, ManyToMany, OneToOne, JoinColumn} from "typeorm";import { ObjectType, Field, Authorized } from 'type-graphql';import { BaseEntity } from './BaseEntity';import { Audit } from './Audit';import { Zone } from './Zone';import hash from '../../components/helpers/hash';import { RefreshToken } from './RefreshToken';const crypto = require('crypto');/** * The Admin Entity, this entity holds data for Admin, Manager and User */@ObjectType()@Entity({ name: 'admins' })export class Admin extends BaseEntity{    @Authorized('ROLE_ADMIN')    @Field(() => String)    @Column({ type: 'enum', enum: ['ROLE_ADMIN', 'ROLE_MANAGER', 'ROLE_USER'], nullable: false, default: 'ROLE_USER'})    role!: string;    @Field(() => String)    @Column({ type: 'text', unique: true, nullable: false })    username!: string;    @Column({ type: 'text', unique: false, nullable: false })    password!: string;    @Column({ type: 'text', unique: true, nullable: false})    salt!: string;    @Field(() => String, { nullable: true })    @Column({ type: 'text', unique: true, nullable: true })    picture!: string;    @Field(() => String)    @Column({ type: 'text', nullable: true, name: 'first_name' })    firstName!: string;    @Field(() => String)    @Column({ type: 'text', nullable: true, name: 'last_name' })    lastName!: string;    @Field(() => String, { nullable: true })    @Column({ type: 'text', unique: true, nullable: true })    email!: string;    @Field(() => String, { nullable: true })    @Column({ type: 'text', nullable: true, name: 'mobile_number' })    mobileNumber!: string;    @OneToOne(() => RefreshToken, refreshToken => refreshToken.admin, {cascade: ['insert', 'update']})    @JoinColumn({name: 'refresh_token_id'})    refreshToken!: RefreshToken;    @OneToMany(() => Audit, audit => audit.admin)    audits!: Audit[];    @ManyToMany(() => Zone, zone => zone.admins, { cascade: ['insert', 'update'] })    zones!: Zone[];    /**     * Before inserting the data, generate the salt and hash the password     */    @BeforeInsert()    hashPassword()    {        this.salt = crypto.randomBytes(16).toString('hex');        this.password = hash.password(this.password, this.salt);    }    /**     * Validate if the password provided matched     * @param password     */    validatePassword(password: string)    {        return this.password === hash.password(password, this.salt);    }}